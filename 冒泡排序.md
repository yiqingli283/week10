## 冒泡排序

冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们的位置交换过来，走访数列重复地进行直到排序完成。因为越大（小）的元素经过交换会慢慢地"浮"到数列的顶端（尾端），就如同碳酸饮料中的气泡一样，故名“冒泡排序”。



**算法原理：以从大到小降序排列为例。**

*第一轮走访开始* ----> 比较相邻的元素- —> 如果第一个元素比第二个元素小，就交换他们的位置，把小的放到后面 ----> 如果第二个比第三个小，同样交换他们的位置，以此类推 ----> 第一轮走访结束

- 这个时候最小的数就“浮”到最右端了

*第二轮走访开始* ----> 比较相邻的元素- —> 如果第一个元素比第二个元素小，就交换他们的位置，把小的放到后面 ----> 如果第二个比第三个小，同样交换他们的位置，以此类推 ----> 第二轮走访结束

- 这时候倒数第二小的数就“浮”到倒数第二列了

*第三轮走访开始* ----> 比较相邻的元素- —> 如果第一个元素比第二个元素小，就交换他们的位置，把小的放到后面 ----> 如果第二个比第三个小，同样交换他们的位置，以此类推 ----> 第三轮走访结束

- 这时候倒数第三小的数就“浮”到倒数第三列了

以此类推，最多经过n-1轮循环

......

所有元素从大到小排序完成

**时间复杂度**

- 若文件的初始状态是正序的，一趟扫描即可完成排序。
  所需的关键字比较轮数C和记录移动轮数M均达到最小值：C=n-1和M=0。
  所以，冒泡排序最好的时间复杂度为O(n)
- 若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i轮关键字的比较(1≤i≤n-1)，且每轮比较都必须移动记录三轮来达到交换记录位置。
  在这种情况下，比较和移动轮数均达到最大值：C=[n(n-1) ]/2=O(n^2) , M=[3n(n-1)]/2=O(n^2)
  所以，冒泡排序的最坏时间复杂度为O(n^2)
- **综上，冒泡排序总的平均时间复杂度为O(n^2)**

代码

```c
#include<stdio.h>
#define N 10 

int main(void)
{
	int arr[N] = { 0,3,2,5,8,4,7,6,9,1 };//创建一个大小为N的数组，方便理解算法
	int i = 0;//控制走访轮数
	int j = 0;//控制数组元素下标
	int temp = 0;//申请一个临时的空间（数组元素交换时需要一个临时空间）

	for (i = 0; i < N - 1; i++)//最多走访N-1轮
	{
		for (j = 0; j < N - 1- i; j++)//每一轮相邻元素只需比较N-1-i次即可
		{
			if (arr[j] < arr[j + 1])
			{
				temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}
	}
	//for循环执行完毕，排序完成，依次打印出排序完成后的数组元素

	for (i = 0; i < N; i++)//变量i清零赋予新的意义：控制打印个数
	{
		printf("%d ", arr[i]);
	}

	return 0;
} 

```



## 希尔排序

希尔排序(Shell Sort)是插入排序的一种。是针对直接插入排序算法的改进。该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。
希尔排序基本思想：
先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。

**希尔排序的思想：**希尔排序的是插入排序的提升(建议先去了解一下插入排序)。它是通过将数据根据每一次的步长不断的将数据进行分组，并且进行处理，使得数值序列整体不会变得太过杂乱。使得在利用插入排序的过程中减少交换的次数，从而使整体得到优化。

步长(step)是怎样计算的呢？

首先先要确定数组中的元素个数，然后进行每次取整除2的处理，直到最后step=1时，停止计算：

例如：一个数组为{9，8，1，3，6，5，2，7}，有数组我们可知这个数组中的元素个数为8个

那么，第一次步长：step = n(数组元素个数) / 2(这里/号为c语言中的取整符号) => 8/2=4;

第二次步长：step = step(这里的step为第一次的step的值)/2 => 4/2 = 2；

第三次步长：step = step(这个同上)/2 => 2/2 = 1；

这三次步长计算为这次排序的所利用到的步长数。

注意：在计算步长的过程中，只有第一次的步长计算利用到了数组的元素个数，后面的第二次以及第三次的步长计算都是由上一次的步长/2。


代码：

```c
#include <stdio.h>
 
void arr_out(int a[8])
{
    int i = 0;
    for(i = 0;i < 8;i++)
    {
        printf("%d ",a[i]);
    }
    printf("\n");
}
 
void arr_sort(int *p,int n)
{
    int step = 0;//步长
    int temp = 0;//用来保存第二段数据
    int i,j;
 
    for(step = n / 2;step > 0;step /= 2)
    {
        for(i = step;i < n;i++)
        {
            temp = p[i];
            for(j = i - step;j >= 0 && p[j] > temp;j -= step)
            {
                p[j + step] = p[j];
                //当满足条件时第一次j+step = i;后面的j+step = 上一次j的值
            }
            p[j + step] = temp;
        }
    }
}
 
int main()
{
    int a[8] = {0};
    int i = 0;
    for(i = 0;i < 8;i++)
    {
        scanf("%d",&a[i]);
    }
 
    arr_sort(a,8);//排序函数
    arr_out(a);//输出函数
 
    return 0;
}
```

